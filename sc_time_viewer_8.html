<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>PC Usage Timeline</title>
  <link rel="icon" href="data:,">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }
    .card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 20px;
      max-width: 1500px;
      margin: 0 auto;
    }
    /* 上部：日付選択＋矢印ボタン */
    .date-controls-wrapper {
      text-align: center;
      margin-bottom: 10px;
    }
    .date-controls {
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }
    .date-picker {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 1em;
    }
    .arrow-button {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 1em;
    }
    /* タイトル */
    .main-title {
      text-align: center;
      margin-bottom: 20px;
    }
    /* 各日のセット（左から：2日前、1日前、今日） */
    .sets-container {
      display: flex;
      justify-content: flex-start;
      gap: 20px;
      overflow-x: auto;
    }
    .day-set {
      flex: 0 0 auto;
      width: 33%;
      min-width: 300px;
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 10px;
      background: #fafafa;
    }
    .day-label {
      text-align: center;
      font-weight: bold;
      margin-bottom: 10px;
    }
    /* 各日セット内の延長時間／視聴時間表示 */
    .total-view-label,
    .total-extension-label {
      text-align: center;
      font-size: 0.9em;
      color: #666;
      margin-bottom: 6px;
    }
    /* セット内：左側タイムマーカー、右側グラフ群 */
    .day-content {
      display: flex;
      gap: 10px;
      height: 600px; /* 固定高さを設定 */
      position: relative;
    }
    .time-markers {
      width: 50px;
      position: relative;
      border-right: 1px solid #ddd;
      height: 100%;
      flex-shrink: 0;
    }
    .time-marker {
      position: absolute;
      width: 100%;
      text-align: right;
      font-size: 0.8em;
      color: #666;
      padding-right: 5px;
      height: 20px;
      margin-top: -10px; /* 高さの半分を負のマージンで設定 */
      line-height: 20px;
      z-index: 1;
    }
    /* マーカーに対応する水平線 */
    .time-marker::after {
      content: '';
      position: absolute;
      left: 100%; /* マーカーの右端から */
      top: 50%;
      width: 100vw; /* 十分な長さ */
      height: 1px;
      background-color: rgba(0,0,0,0.05);
      z-index: -1;
    }
    .graphs-container {
      display: flex;
      flex: 1;
      flex-direction: row;
      gap: 10px;
      overflow-x: auto;
      height: 100%;
      justify-content: center;
      position: relative;
    }

    /* 各タイムライン（1PCまたは総視聴）のラッパー */
    .timeline-wrapper {
      display: inline-block;
    }
    .pc-info {
      text-align: center;
      margin-bottom: 12px;
      height: 40px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .pc-title {
      font-size: 0.9em;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100px;
    }
    .total-minutes {
      font-size: 0.8em;
      color: #666;
      margin-top: 4px;
    }
    .timeline {
      position: relative;
      background: #f8f8f8;
      padding: 4px;
      border-radius: 4px;
      height: 100%; /* 変更前: 500px → 変更後: 100%（親要素 day-content の高さ 600px に合わせる） */
      width: 90px;
    }
    .loading, .error {
      text-align: center;
      padding: 20px;
      color: #666;
    }
    .error {
      color: #dc2626;
    }
    .analysis-summary {
      border-top: 1px solid #ddd;
      padding-top: 10px;
      margin-top: 10px;
      font-size: 0.9em;
      color: #444;
    }
    /* 時間帯セグメント */
    .time-segment {
      position: absolute;
      left: 0;
      right: 0;
      border-radius: 2px;
      transition: opacity 0.2s;
    }
    .time-segment:hover {
      opacity: 0.8;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <!-- 共通ヘッダーの読み込み -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <div id="commonHeader"></div>
  <script src="common-header.js"></script>
  <div class="card">
    <!-- 上部：日付選択 -->
    <div class="date-controls-wrapper">
      <div class="date-controls">
        <button id="prevDate" class="arrow-button">&#8592;</button>
        <input type="date" id="datePicker" class="date-picker">
        <button id="nextDate" class="arrow-button">&#8594;</button>
      </div>
    </div>
    <!-- 各日のセット（左から：2日前、1日前、今日） -->
    <div id="setsContainer" class="sets-container">
      <!-- 各日セットはJSで生成 -->
    </div>
  </div>

  <script>
    // URLのGETパラメータで"project_id"が指定されていればそれを使用
    const urlParams = new URLSearchParams(window.location.search);
    const SUPABASE_PROJECT_ID = urlParams.get('project_id') || 'xalrqqutkxzwzvahqpjg';
    const SUPABASE_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co`;
    const SUPABASE_KEY = urlParams.get('supabase_key') || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhhbHJxcXV0a3h6d3p2YWhxcGpnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzkyNDE2MDIsImV4cCI6MjA1NDgxNzYwMn0.OzfyNlLHmZJOiWnCgsUCnvA9npaDXzVeASr-HVOT1MA';

    // Supabaseクライアントの初期化
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
      auth: {
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: true
      }
    });

    let USER_ID = null;
    // 表示の定数：開始・終了時間を0-24時に変更
    const DISPLAY_START_HOUR = 0; // 0:00 から
    const DISPLAY_END_HOUR = 24; // 24:00 まで

    // セッションチェックと初期化
    async function initializeWithSession() {
      try {
        const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();
        
        if (sessionError) throw sessionError;
        if (!session) {
          window.location.href = 'auth_test_login.html';
          return;
        }

        USER_ID = session.user.id;
        // 日付の初期化とデータ取得を開始
        const now = new Date();
        const jstDate = new Date(now.getTime() + (9 * 60 * 60 * 1000));
        document.getElementById('datePicker').value = formatDate(jstDate);
        
        // 前後の日付移動ボタンのイベントを設定
        document.getElementById('prevDate').addEventListener('click', () => {
          const currentDate = new Date(document.getElementById('datePicker').value);
          currentDate.setDate(currentDate.getDate() - 1);
          document.getElementById('datePicker').value = formatDate(currentDate);
          fetchAndRenderAllDays();
        });
        
        document.getElementById('nextDate').addEventListener('click', () => {
          const currentDate = new Date(document.getElementById('datePicker').value);
          currentDate.setDate(currentDate.getDate() + 1);
          document.getElementById('datePicker').value = formatDate(currentDate);
          fetchAndRenderAllDays();
        });
        
        // 日付選択時のイベントを設定
        document.getElementById('datePicker').addEventListener('change', fetchAndRenderAllDays);
        
        await fetchAndRenderAllDays();
      } catch (error) {
        console.error('セッション初期化エラー:', error);
        window.location.href = 'auth_test_login.html';
      }
    }

    // ヘルパー関数：分を HH:MM 形式に
    function getTimeString(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    }
    
    function getMinutesFromTime(hours, minutes) {
      return hours * 60 + minutes;
    }
    
    // 時刻文字列（例："16:50-16:50"）をパースして開始・終了分を取得
    function parseTimeRange(rangeStr) {
      const [startStr, endStr] = rangeStr.split('-');
      const [startHour, startMin] = startStr.split(':').map(n => parseInt(n, 10));
      const [endHour, endMin] = endStr.split(':').map(n => parseInt(n, 10));
      return {
        start: startHour * 60 + startMin,
        end: endHour * 60 + endMin
      };
    }
    
    // 時間帯をマージする補助関数
    function mergeTimeRanges(ranges) {
      // 重複を除去
      ranges = [...new Set(ranges)];
      
      // 文字列を数値に変換してソート
      const parsed = ranges.map(range => parseTimeRange(range))
        .sort((a, b) => a.start - b.start);
      
      // 連続する時間帯をマージ
      const merged = [];
      let current = null;
      
      for (const range of parsed) {
        if (!current) {
          current = {...range};
          continue;
        }
        
        if (range.start <= current.end) {
          current.end = Math.max(current.end, range.end);
        } else {
          merged.push(`${getTimeString(current.start)}-${getTimeString(current.end)}`);
          current = {...range};
        }
      }
      
      if (current) {
        merged.push(`${getTimeString(current.start)}-${getTimeString(current.end)}`);
      }
      
      return merged;
    }
    
    // タイムマーカー生成
    function createTimeMarkers() {
      const container = document.createElement('div');
      container.className = 'time-markers';
      
      // 表示範囲の定義（0:00-24:00）
      const totalMinutes = 24 * 60;  // 1日の総分数
      
      // 1時間ごとにマーカーを表示
      for (let hour = 0; hour <= 24; hour++) {
        const marker = document.createElement('div');
        marker.className = 'time-marker';
        
        // 位置計算をシンプルに（1時間 = 4.166...%）
        const topPercent = (hour / 24) * 100;
        marker.style.top = `${topPercent}%`;
        marker.textContent = `${hour.toString().padStart(2, '0')}:00`;
        
        container.appendChild(marker);
      }
      
      return container;
    }
    
    // 新たなタイムライン描画関数：時間帯文字列の配列から描画
    function createTimelineFromRanges(pcName, timeRanges, activityCount, isTotal = false) {
      const wrapper = document.createElement('div');
      wrapper.className = 'timeline-wrapper';
      // wrapperを相対位置にして、内部の絶対配置要素の基準にする
      wrapper.style.position = 'relative';

      // 以下、グラフのレイアウトに影響しないように、
      // PC情報を別レイヤ（class1構成）として絶対配置します。
      const pcInfo = document.createElement('div');
      // 必要に応じてCSSで「.pc-info.class1」のスタイルも定義可能（ここではインラインスタイル）
      pcInfo.className = 'pc-info class1';
      pcInfo.style.position = 'absolute';
      pcInfo.style.top = '0';
      pcInfo.style.left = '0';
      pcInfo.style.width = '100%';
      pcInfo.style.height = '40px';
      // ユーザー操作等に干渉しないように（必要なら）
      pcInfo.style.pointerEvents = 'none';
      pcInfo.style.zIndex = '1';

      const title = document.createElement('h2');
      title.className = 'pc-title';
      title.textContent = isTotal ? '総視聴時間' : pcName;
      title.title = title.textContent;

      const totalMins = document.createElement('div');
      totalMins.className = 'total-minutes';
      totalMins.textContent = `${activityCount}分`;

      // PC情報を絶対配置のコンテナに追加
      pcInfo.appendChild(title);
      pcInfo.appendChild(totalMins);
      // ここでwrapper内に追加しますが、絶対配置のためグラフ位置の計算には影響しません
      wrapper.appendChild(pcInfo);

      // タイムライン本体（グラフ）の作成
      const timeline = document.createElement('div');
      timeline.className = `timeline ${isTotal ? 'total-usage' : ''}`;
      timeline.style.position = 'relative'; // 通常表示
      // ※ このタイムラインは day-content 内の固定高さ（例：600px）にフィットする前提です

      // タイムラインに時間帯セグメントを追加（位置計算は0時～24時の割合で実施）
      timeRanges.forEach(rangeStr => {
        const { start, end } = parseTimeRange(rangeStr);
        const segDiv = document.createElement('div');
        segDiv.className = 'time-segment';
        const topPercent = (start / (24 * 60)) * 100;
        const heightPercent = ((end - start) / (24 * 60)) * 100;
        segDiv.style.top = `${topPercent}%`;
        segDiv.style.height = `${heightPercent}%`;
        segDiv.style.left = '4px';
        segDiv.style.right = '4px';
        segDiv.style.backgroundColor = isTotal ? '#22c55e' : '#2563eb';
        segDiv.title = `${getTimeString(start)} - ${getTimeString(end)}`;
        timeline.appendChild(segDiv);
      });

      wrapper.appendChild(timeline);

      return wrapper;
    }
    
    // 日付を YYYY-MM-DD 形式に
    function formatDate(date) {
      return date.toISOString().split('T')[0];
    }
    
    // APIリクエスト用の共通ヘッダー
    const HEADERS = {
      'apikey': SUPABASE_KEY,
      'Authorization': `Bearer ${SUPABASE_KEY}`,
      'Content-Type': 'application/json'
    };
    
    // １日のセット生成：RPC経由で新SQL関数からデータを取得してタイムライン描画
    async function renderDaySet(dateStr) {
      const daySet = document.createElement('div');
      daySet.className = 'day-set';
      
      const dayLabel = document.createElement('div');
      dayLabel.className = 'day-label';
      dayLabel.textContent = dateStr;
      
      // 視聴時間の表示を追加
      const totalViewLabel = document.createElement('div');
      totalViewLabel.className = 'total-view-label';
      const totalExtensionLabel = document.createElement('div');
      totalExtensionLabel.className = 'total-extension-label';
      
      daySet.appendChild(dayLabel);
      daySet.appendChild(totalViewLabel);
      daySet.appendChild(totalExtensionLabel);
      
      const dayContent = document.createElement('div');
      dayContent.className = 'day-content';
      
      const markersContainer = createTimeMarkers();
      dayContent.appendChild(markersContainer);
      
      const graphsContainer = document.createElement('div');
      graphsContainer.className = 'graphs-container';
      graphsContainer.innerHTML = '<div class="loading">データを読み込んでいます...</div>';
      dayContent.appendChild(graphsContainer);
      
      daySet.appendChild(dayContent);
      
      try {
        // リクエストペイロード形式
        const requestBody = {
          target_user_id: USER_ID,
          target_date: dateStr
        };

        console.log('Request to get_time_ranges_by_user:', {
          url: `${SUPABASE_URL}/rest/v1/rpc/get_time_ranges_by_user`,
          headers: HEADERS,
          body: requestBody
        });

        const usageResponse = await fetch(
          `${SUPABASE_URL}/rest/v1/rpc/get_time_ranges_by_user`,
          {
            method: 'POST',
            headers: HEADERS,
            body: JSON.stringify(requestBody)
          }
        );

        if (!usageResponse.ok) {
          throw new Error(`Usage fetch error: ${usageResponse.status} ${usageResponse.statusText}`);
        }

        const usageData = await usageResponse.json();
        console.log('Parsed usage data:', usageData);

        graphsContainer.innerHTML = '';

        if (!Array.isArray(usageData) || usageData.length === 0) {
          graphsContainer.innerHTML = '<div class="loading">この日のデータはありません</div>';
        } else {
          // 各PCのタイムライン描画
          for (const row of usageData) {
            let timeRanges = row.time_ranges;
            if (typeof timeRanges === 'string') {
              timeRanges = JSON.parse(timeRanges);
            }
            timeRanges = mergeTimeRanges(timeRanges);
            const pcName = await getPcName(row.pc_id);
            const timeline = createTimelineFromRanges(pcName, timeRanges, row.activity_count);
            graphsContainer.appendChild(timeline);
          }
        }

        console.log('Request to get_total_watch_time:', {
          url: `${SUPABASE_URL}/rest/v1/rpc/get_total_watch_time`,
          headers: HEADERS,
          body: requestBody
        });

        const totalResponse = await fetch(
          `${SUPABASE_URL}/rest/v1/rpc/get_total_watch_time`,
          {
            method: 'POST',
            headers: HEADERS,
            body: JSON.stringify(requestBody)
          }
        );

        if (!totalResponse.ok) {
          throw new Error(`Total time fetch error: ${totalResponse.status} ${totalResponse.statusText}`);
        }

        const totalDataArray = await totalResponse.json();
        const totalData = totalDataArray[0] || {};
        
        console.log('Request to analyze_time_difference:', {
          url: `${SUPABASE_URL}/rest/v1/rpc/analyze_time_difference`,
          headers: HEADERS,
          body: requestBody
        });

        const diffResponse = await fetch(
          `${SUPABASE_URL}/rest/v1/rpc/analyze_time_difference`,
          {
            method: 'POST',
            headers: HEADERS,
            body: JSON.stringify(requestBody)
          }
        );

        if (!diffResponse.ok) {
          throw new Error(`Time difference fetch error: ${diffResponse.status} ${diffResponse.statusText}`);
        }

        const diffDataArray = await diffResponse.json();
        const diffData = diffDataArray[0] || {};
        
        // 分析サマリーを表示
        totalViewLabel.textContent = `許可: ${totalData.total_time}分 (追加: ${totalData.total_added_minutes}分, ベース: ${totalData.default_time}分)`;

        // 差分が正の場合：「超過してる」、負の場合：「許容」、0の場合はそのまま表示
        let diffLabel = "";
        if (diffData.time_difference > 0) {
          diffLabel = `${diffData.time_difference}分（超過してる）`;
        } else if (diffData.time_difference < 0) {
          diffLabel = `${Math.abs(diffData.time_difference)}分（許容）`;
        } else {
          diffLabel = `${diffData.time_difference}分`;
        }
        totalExtensionLabel.textContent = `利用時間: ${diffData.unique_minutes_count}分, 差分: ${diffLabel}`;
        
      } catch (error) {
        console.error('Error details:', error);
        graphsContainer.innerHTML = '<div class="error">データの取得に失敗しました</div>';
      }
      return daySet;
    }
    
    // 選択日とその前日2日分のセットを生成
    async function fetchAndRenderAllDays() {
      const setsContainer = document.getElementById('setsContainer');
      setsContainer.innerHTML = '<div class="loading">データを読み込んでいます...</div>';
      
      const selectedDateStr = document.getElementById('datePicker').value;
      const selectedDate = new Date(selectedDateStr);
      const dates = [
        formatDate(new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate() - 1)),
        formatDate(new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate() - 0)),
        formatDate(selectedDate)
      ];
      
      try {
        const daySetPromises = dates.map(dateStr => renderDaySet(dateStr));
        const daySets = await Promise.all(daySetPromises);
        setsContainer.innerHTML = '';
        daySets.forEach(daySet => setsContainer.appendChild(daySet));
      } catch (error) {
        console.error('Error fetching data:', error);
        setsContainer.innerHTML = '<div class="error">データの取得に失敗しました</div>';
      }
    }
    
    // PC名を取得する関数
    async function getPcName(pcId) {
      const requestBody = {
        p_pc_id: pcId
      };

      try {
        const response = await fetch(
          `${SUPABASE_URL}/rest/v1/rpc/get_pc_name`,
          {
            method: 'POST',
            headers: HEADERS,
            body: JSON.stringify(requestBody)
          }
        );

        if (!response.ok) {
          throw new Error(`PC name fetch error: ${response.status}`);
        }

        const pcName = await response.json();
        return pcName || pcId; // PCの名前が取得できない場合はIDを返す
      } catch (error) {
        console.error('Error fetching PC name:', error);
        return pcId; // エラーの場合はIDを返す
      }
    }
    
    // 初期化を実行
    initializeWithSession();
  </script>
</body>
</html>